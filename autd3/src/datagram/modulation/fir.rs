use std::sync::Arc;

use crate::derive::*;

#[derive(Modulation, Debug)]
pub struct Fir<M: Modulation> {
    m: M,
    #[no_change]
    config: SamplingConfig,
    loop_behavior: LoopBehavior,
    filter: Vec<f32>,
}

impl<M: Modulation> Fir<M> {
    fn new(m: M, filter: impl IntoIterator<Item = f32>) -> Self {
        Self {
            config: m.sampling_config(),
            loop_behavior: m.loop_behavior(),
            m,
            filter: filter.into_iter().collect(),
        }
    }
}

pub trait IntoFir<M: Modulation> {
    fn with_fir(self, filter: impl IntoIterator<Item = f32>) -> Fir<M>;
}

impl<M: Modulation> IntoFir<M> for M {
    fn with_fir(self, filter: impl IntoIterator<Item = f32>) -> Fir<M> {
        Fir::new(self, filter)
    }
}

impl<M: Modulation> Modulation for Fir<M> {
    fn calc(&self) -> Result<Arc<Vec<u8>>, AUTDInternalError> {
        let src = self.m.calc()?;
        let src_len = src.len() as isize;
        let filter_len = self.filter.len() as isize;
        Ok(Arc::new(
            (0..src_len)
                .map(|i| {
                    (0..filter_len)
                        .map(|j| {
                            src[(i + j - filter_len / 2).rem_euclid(src_len) as usize] as f32
                                * self.filter[j as usize]
                        })
                        .sum::<f32>() as u8
                })
                .collect(),
        ))
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        modulation::{Custom, Fourier},
        prelude::Sine,
    };
    use autd3_driver::defined::{kHz, Hz};

    use super::*;

    #[rstest::rstest]
    #[test]
    #[case::freq_4k(SamplingConfig::new_nearest(4. * kHz))]
    #[case::freq_8k(SamplingConfig::new_nearest(8. * kHz))]
    fn test_sampling_config(#[case] config: SamplingConfig) {
        assert_eq!(
            config,
            Custom::new(&[u8::MIN; 2], config)
                .unwrap()
                .with_fir([1.0])
                .sampling_config()
        );
    }

    #[test]
    fn test() -> anyhow::Result<()> {
        let lpf = [
            0.,
            2.336732360626E-6,
            8.982680545673E-6,
            1.888706149541E-5,
            3.0300969961672E-5,
            4.0758486723429E-5,
            4.7081817710912E-5,
            4.5422119057022E-5,
            3.134882495843E-5,
            0.,
            -5.3695722244499E-5,
            -0.00013471873968189,
            -0.00024757806234809,
            -0.00039585599495572,
            -0.00058169066998789,
            -0.00080521720383991,
            -0.0010639960253245,
            -0.0013524637633698,
            -0.0016614472914628,
            -0.0019777844835784,
            -0.0022840954285658,
            -0.0025587449300976,
            -0.002776030943583,
            -0.0029066242556165,
            -0.0029182725208466,
            -0.0027767672933891,
            -0.0024471566906237,
            -0.001895169738564,
            -0.0010888023132564,
            0.,
            0.0013936387981507,
            0.0031072246010693,
            0.0051470926241822,
            0.0075095609538417,
            0.010180013520509,
            0.013132379171826,
            0.016329062309131,
            0.019721360653499,
            0.023250382720482,
            0.026848452707599,
            0.030440965099539,
            0.033948626819086,
            0.037290002636792,
            0.040384261141651,
            0.043154005027742,
            0.04552806166737,
            0.047444108498447,
            0.04885101286893,
            0.049710777488976,
            0.05,
            0.049710777488976,
            0.04885101286893,
            0.047444108498447,
            0.04552806166737,
            0.043154005027742,
            0.040384261141651,
            0.037290002636792,
            0.033948626819086,
            0.030440965099539,
            0.026848452707599,
            0.023250382720482,
            0.019721360653499,
            0.016329062309131,
            0.013132379171826,
            0.010180013520509,
            0.0075095609538417,
            0.0051470926241822,
            0.0031072246010693,
            0.0013936387981507,
            0.,
            -0.0010888023132564,
            -0.001895169738564,
            -0.0024471566906237,
            -0.0027767672933891,
            -0.0029182725208466,
            -0.0029066242556165,
            -0.002776030943583,
            -0.0025587449300976,
            -0.0022840954285658,
            -0.0019777844835784,
            -0.0016614472914628,
            -0.0013524637633698,
            -0.0010639960253245,
            -0.00080521720383991,
            -0.00058169066998789,
            -0.00039585599495572,
            -0.00024757806234809,
            -0.00013471873968189,
            -5.3695722244499E-5,
            0.,
            3.134882495843E-5,
            4.5422119057022E-5,
            4.7081817710912E-5,
            4.0758486723429E-5,
            3.0300969961672E-5,
            1.888706149541E-5,
            8.982680545673E-6,
            2.336732360626E-6,
            0.,
        ];

        assert_eq!(
            vec![
                126, 131, 135, 140, 144, 148, 152, 156, 160, 164, 167, 170, 173, 175, 178, 180,
                181, 182, 183, 184, 184, 184, 183, 182, 181, 180, 178, 175, 173, 170, 167, 164,
                160, 156, 152, 148, 144, 140, 135, 131, 126, 122, 117, 113, 108, 104, 100, 96, 92,
                88, 85, 82, 79, 77, 74, 73, 71, 70, 69, 68, 68, 68, 69, 70, 71, 73, 74, 77, 79, 82,
                85, 88, 92, 96, 100, 104, 108, 113, 117, 122
            ],
            *Fourier::new([Sine::new(50 * Hz), Sine::new(1000 * Hz)])?
                .with_fir(lpf)
                .calc()?
        );

        Ok(())
    }
}
